# TransactionServer-Team10
https://www.youtube.com/watch?v=7RbJNK4t4Rg
Project Description
Please read the following paragraphs carefully and contact me with any questions that you have.
Data objects
Your transaction server will manage X number of data objects that can be thought of as banking accounts; each account is holding a certain amount of money. The number of accounts is configurable.
When you start your transaction server, each account is initialized to some configurable amount, e.g. $10. Accounts can be "over-drafted", resulting in a negative balance. For simplicity, we will assume that accounts contain only full dollar amounts. This will allow you to represent account balances by simple integers.
Operations on data objects
Account balances can be read and can be written - those are the two fundamental operations that can be applied to accounts. This allows, e.g. for reading an account balance and, depending on the value read, writing a different balance back. The combined effect of these two operations can be viewed as a withdrawal or a deposit, depending on whether the original balance was larger or smaller than the resulting one.
Because accounts can only contain full dollar amounts, write operations can also only write full dollar amounts.
Transactions
While conceptually your transaction server can support any number of read/write operations on its data objects in any order, we want to introduce yet another simplification as follows. All transactions hitting your server will only ever do the same set of operations that each and every transaction is comprised of: an arbitrarily chosen dollar amount is withdrawn from an arbitrarily chosen account and deposited onto another, arbitrarily chosen account. I ask you to always stay strictly at the level of elementary read/write operations, instead of  implementing higher level constructs like withdrawal and deposit.
As can be easily seen, this results in a "zero sum game", i.e. after any properly run number of such transactions has completed, the sum of all balances over all X accounts should be e.g. $10 times X.
From the above description it should be clear that all transactions look the same in what they do. However, a run of a certain transaction will be different from any other run of another transaction in that the dollar amounts to be transferred between accounts is chosen by chance, as are the source and destination accounts. Needless to say, transactions are uniquely identified by their transaction IDs. 
While you are allowed to make the assumptions about what all transactions uniformly look like, the only entity that is allowed to implement a "hard-coded" representation of activities that a transaction is comprised of is the client application itself. On the other hand, your transactional system, including the server proxy object on the client side, is absolutely unaware of the assumption of such a predefined sequence of activities, i.e. it can handle any activities in any order whatsoever, without any limitation or underlying assumption.
Although transactions contain a fixed set of operations, they need to be properly opened, as well as closed. But, again for reasons of simplicity, we assume that it is not possible to abort a transaction, neither from the server, nor from the client's side.
Locks
Unfortunately, the above description of how your (one type of) transactions are supposed to be run implies that race conditions exist that will render your data objects inconsistent and thus useless, if no precautions are taken. To guarantee the proper working of concurrently running transactions and eliminate the detrimental effects of race conditions, your transaction server is supposed to employ locking. In order to observe the effects of locking, or, the absence of such a precaution, your transaction server has to be implemented such that the presence of a locking scheme is configurable.
Deadlocks
In a system that relies on locking in order to manage the concurrency and abortion issues that we discussed, deadlocks are common. In your application you need to implement logic that prevents deadlocks from occurring. I commented in class on how to do that. As understanding the reasoning behind the logic of the algorithm is important, I present it again here:
The idea is to check for the potential of deadlocks occurring right at the moment when a transaction tries to acquire a lock. In this situation, two things may happen. Either the lock is being granted and we are fine. Alternatively, the lock request is denied because it conflicts with a lock that has already been set by another transaction. That means that the transaction requesting the lock needs to wait for the other transaction(s) to release the lock. And this is the critical moment where a circle of transactions waiting for each other may build. What we can do though is the following. We check all the locks that the current transaction is holding. If there is any other transaction waiting for any of those locks we ABORT the current transaction and thus break a cycle that may be in the process of forming. A simple, yet efficient measure to prevent deadlocks from happening.
Client
The (one) client that you will develop may execute any number of transactions, each one in its own thread. In class I commented in length on what that will look like, i.e. you will have some server proxy objects that mimic the presence of the server on the client side and provide an interface that the client talks to. These objects, from a client perspective, represent the transactions. Overall, the number of transactions to be run on the server is configurable. Clients will accept the connectivity information of the server as a configurable property. Convince yourself that all the client is doing with this information is to pass it on to the server proxy object, the latter handling the low-level communication with the server and advertising the transactional API to the client.
Your client(s) need to connect to your transaction server over a TCP/IP network.
